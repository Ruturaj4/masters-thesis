
\chapter{Related and Future Work}

This section discusses the work which has been done in the past, which is related to the goal of this work. This is not limited to the similar techniques used, but also includes a broad overview of memory safety techniques in general. This section also discusses the future work to be done to improve the effectiveness of this technique.

\section{Related Work}

Memory safety violations is one of the oldest issues in programming and computing. These violations occur due to lack of memory safety in languages like \texttt{C} and \texttt{C++}. Buffer overflow vulnerabilities get popularity when Morris Worm \citep{Spafford:1989:IWP:66093.66095} is introduced in 1988 and the overflow attacks are still relevant till this date. There are a number of defences have been proposed to defend against memory attacks (like buffer overflow), for e.g. stack canaries, ASLR, non executable memory, PIE (position Independent Executable), re-randomization techniques, etc. make the attack using buffer overflow very difficult. But, even combination of these defenses can still be circumvented.

Laszlo Szekeres et al. \citep{6547101} explain the type of attacks and the phases in which these attacks can be exploited, memory safety being first and one of the important phases. To provide complete memory safety, spatial as well as temporal memory safety should be provided. In this section, we will only consider the work related to provide protection against memory safety attacks. Numerous approaches have been proposed to provide memory safety against vulnerabilities in low level languages. Memory safety approaches can be categorized as object based, pointer based and tripwire approaches. Now, we look at some of the popular spatial and complete memory safety approaches.

\subsection{Work Focused On Providing Spatial Safety (Primarily)}

Richard W. M. Jones and Paul H. J. Kelly \citep{jones1997backwards} propose a compiler based technique, which does pointer and array bounds checking, without changing pointer representation. Dhujrati et al. \citep{dhurjati2006backwards} propose an improved version of Kelly's technique. They use a technique called automatic pool allocation \citep{lattner2005automatic}, which is based on memory partitioning. SAFECode \citep{dhurjati2006safecode} is another object based approach (improved version of their previous work). It guarantees some from of spatial and temporal safety. CCured \citep{Necula:2002:CTR:565816.503286} ensures type safety in \texttt{C} programs by categorizing pointers into different types (safe pointer, sequence pointer and dynamic pointer) and adding the checks accordingly, either during compile time or during run time. Hence, to keep pointer metadata, it needs to extend the pointer structure (fat pointers). It requires to convert \texttt{C} program into CCured representation and thus it relies on source code. Ruwase et al. proposes a compiler based technique called CRED \citep{ruwase2004practical} which dynamically detects the buffer overflows. Baggy bounds checking \citep{akritidis2009baggy} is an object based technique, which utilizes allocation bounds instead of object bounds. Light weight bounds checking or LBC \citep{Hasabnis:2012:LBC:2259016.2259034} is another spatial memory error detection technique, which provides better performance than the Baggy Bounds checking technique. Hardbound \citep{devietti2008hardbound} is a combination of software and hardware techniques which ensures complete spatial safety. In this approach, the software (compiler or run-time system) allocates pointer bounds and the hardware checks for valid pointer accesses and propagates bounds metadata if necessary. SoftBound \citep{nagarakatte2009softbound} is a compiler based technique which enforces complete spatial safety, without any hardware support. The basic idea of our work is based on SoftBound approach, as explained before. AddressSanitizer \citep{serebryany2012addresssanitizer} is a trip-wire technique which detects buffer overflows and use-after-free errors. Code-pointer integrity \citep{kuznetsov2014code} prototype enforces spatial safety, though it is primarily made to defend against control flow hijack attacks. Intel MPX \citep{oleksenko2017intel} is a recent work by Intel. It provides spatial safety using hardware assistance.

\subsection{Work Focused On Providing Complete Memory Safety}

SafeC \citep{austin1994efficient} is a fat pointer approach, which provides both spatial and temporal safety. Patil et al. \cite{patil1995efficient} propose a memory safety (spatial plus temporal) technique using shadow processor. The idea is to use one processor to execute the program and the other (shadow) to monitor that program. Cyclone \citep{Jim:2002:CSD:647057.713871} is another fat pointer based approach, which is source code dependent. Cyclone is a \texttt{C} dialect which transforms \texttt{C} code in Cyclone code and uses static analysis and/or adds dynamic checks to ensure safety. It also detects temporal memory errors like dangling pointers. Yong et al. \citep{yong2003protecting} propose a memory safety approach using static code analysis and instrumentation techniques. Xu et al. \citep{xu2004efficient} present a memory safety approach which requires source code transformation to add dynamic checks. Watchdog \citep{nagarakatte2012watchdog} and WatchdogLite \citep{nagarakatte2014watchdoglite} ensure spatial and temporal memory safety using hardware assistance. One more approach from Nagarakatte et al. called SoftBoundCETS \citep{nagarakatte2015everything} is focused on providing complete memory safety. It combines SoftBound approach (for spatial safety) and CETS approach (for temporal memory safety) \citep{nagarakatte2010cets} to achieve complete safety. MemSafe \citep{simpson2013memsafe} is a compiler based technique which provides complete memory safety. SHAKTI-MS \citep{Das:2019:SRP:3316482.3326356} is a light-weight processor made to offer spatial and temporal safety in \texttt{C} programs. The idea is store pointer metadata on stack, to remove the need of external table (like shadow table) and to reduce access overhead. There are a number of approaches which are only focused on providing complete temporal safety (and not spatial safety), but we will not cover those approaches here.

\section{Future Work}
In this section, we discuss multiple future research directions and things that need to be improved. We take inspiration from related studies to improve our technique.

\subsection*{Temporal Safety}
The end goal of our work is to provide complete memory safety, but our technique currently focuses on providing spatial safety only. Ensuring temporal safety and eventually providing complete memory safety will be the principle future direction. It is important to provide complete memory safety to make low level languages safe from memory corruption attacks. One way to provide temporal safety is to extend this work on the basis of SoftBoundCETS \citep{nagarakatte2015everything} technique. They use lock and key metadata with pointers along with the pointer bounds metadata. Hence lock, key and bounds information are propagated together. Key is the unique allocation identifier coupled with each memory allocation and lock is the pointer to a memory location. The access is valid if key and the value at the location pointer by lock matches. Key and lock provides temporal safety, while bounds metadata provides spatial safety.

\subsection*{Completeness}
As discussed before in the experiments section, about 57\% test cases are passed and hence about 43\% cases failed. But, most of this cases are failed due to incapability of Ghidra to predict the correct owner access information. Ghidra has just been open sourced and it is still in the process of improvement. Therefore, instead of totally relying on Ghidra algorithm, certain instruction pattern recognition or machine learning techniques can be used to learn the instruction patterns, detect correct owners, accesses and consequently improve the detection algorithm of our script. Completeness is necessary to remove false positives and detect all the true positives that may remain undetected.

\subsection*{Optional Debugging Information}
Our implementation currently requires program to be compiled by keeping the debugging information, i.e. program must be compiled with -g flag (when compiled using gcc). This helps keeping a lot of information from source code (for e.g. exact variable names). Ghidra tool prediction works better given that this information is present. It is not always possible for the developer to compile the program keeping the debugging information, mainly for the reasons such as code privacy, size requirements, etc. and the binary is mostly optimized for performance, security, privacy, size restrictions, etc. reasons. Also, already compiled binaries and binaries from unknown authors restrict the requirement of keeping debugging information. It is interesting to see how much information can be extracted from the binary which does not contain any symbol information or which has been heavily optimized.

\subsection*{Overhead Reduction and SPEC Benchmark Checks}
It can be observed that, our Pintool incurs about 6\% of overhead on top of the overhead incurred by a minimal Pintool. We will use longer running benchmarks from the SPEC suite to assess the overhead compared to a native execution. It is also important to check if any reduction in the overall overhead is possible by tweaking our Pintool program to decrease the instrumentation checks. For e.g. instrumentation can be added only for store instructions to check for possible buffer overrun. If possible, other instrumentation tools can also be considered.

\subsection*{Other Improvements}
Pointer bounds narrowing and arbitrary or guileful type casts check are also important, but we have not taken those into consideration in our work and will be one priority in our future work considerations. Our work is currently limited to x68-64 architecture and have not been implemented for other architectures. To increase the reach of this technique, it can definitely be made to support other architectures.