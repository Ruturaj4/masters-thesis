
\chapter{Introduction}
Low level languages like \texttt{C} and \texttt{C++} are popular amongst developers for their memory management and control capabilities, closeness to the system, high portability and excellent performance benefits. However, these languages are well known for lack of memory safety and prone to memory corruption attacks, which can not only leak program information, but also can take control of the whole system. High level languages like \texttt{Java} can be used instead, because of their advantages such as type safety, garbage collection, etc. But the advantages of \texttt{C} and \texttt{C++} over high level languages make them more popular in several application domains. Also, most of system software, compilers, database software have been written in these low level languages and replacing these languages with relatively safe high level languages in the near future is likely impossible.

Memory safety can be classified into two types - spatial safety and temporal safety. Spatial error is invoked by overflowing assigned object (e.g. buffer overrun) and temporal error is invoked by accessing unallocated memory (reusing a deallocated object). Ensuring spatial as well as temporal memory safety is important to provide complete memory safety. Attacks are crafted by leveraging memory safety vulnerabilities in low level languages. These attacks got popularity when Morris Worm \citep{Spafford:1989:IWP:66093.66095} was introduced and are still relevant today, evident by the introduction of more recent Heartbleed bug (buffer underflow) \citep{durumeric2014matter} and several other similar attacks. Diverse efforts have been established to provide memory safety in low level languages, at source code, compiler, operating system and hardware level [\citep{nagarakatte2009softbound}, \citep{dynamicinstrumentationusage}, \citep{dhurjati2006backwards}, \citep{dhurjati2006safecode}, \citep{lattner2005automatic}, \citep{ruwase2004practical}, \citep{akritidis2009baggy}, \citep{Hasabnis:2012:LBC:2259016.2259034}, \cite{Necula:2002:CTR:565816.503286}, \citep{Jim:2002:CSD:647057.713871}, \citep{devietti2008hardbound}, \citep{austin1994efficient}, \citep{patil1995efficient}, \citep{yong2003protecting}, \citep{xu2004efficient}, \citep{nagarakatte2012watchdog}, \citep{nagarakatte2014watchdoglite}, \citep{simpson2013memsafe}, \citep{Das:2019:SRP:3316482.3326356}, \citep{serebryany2012addresssanitizer}, \citep{kuznetsov2014code}, \citep{nagarakatte2010cets}, \citep{nagarakatte2015everything}, \citep{oleksenko2017intel}], although none is perfect.

This work introduces a novel approach that ensures spatial safety in compiled binaries using static analysis (also, reverse engineering techniques) and dynamic instrumentation. Our implementation requires no source code support and it takes only raw binary as an input. Static analysis is used to predict the variable (array or pointer) accesses and dynamic instrumentation is used to add run time checks. Our implementation requires no changes in source code, compiler software or operating system software. The implementation is based on SoftBound approach, which is a pointer based technique used to provide spatial safety, although softbound requires compiler support and thus source code as an input \citep{nagarakatte2009softbound}. We assume that the binary is compiled by keeping the debugging information (this helps us our static analysis step). We use NSA's Ghidra tool for static analysis (and reverse engineering) and Intel's Pin framework for dynamic instrumentation. SARD benchmarks \citep{sardcite} are used to test the effectively (detection and overhead) of our work.

The rest of the thesis is arranged as follows. 
Chapter 2 gives background information about memory errors, softbound technique, analysis and instrumentation frameworks used. 
Chapter 3 discusses our implementation in details, Chapter 4 presents our experimental results, Chapter 5 presents related and future work and Chapter 6 gives the conclusion.